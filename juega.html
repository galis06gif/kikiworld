<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Kiki's Game</title>
<script>
if(sessionStorage.getItem("accessGranted") !== "true"){
    window.location.href = "check.html";
}
</script>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    background:#b0e0ff; 
    font-family:sans-serif; 
    overflow:hidden;
  }
  #bgCanvas{
    position:fixed;
    top:0; left:0;
    width:100vw; height:100vh;
    z-index:0;
    filter: blur(1.5px); /* Desenfoque suave */
  }
  #gameCanvas{
    display:block;
    position:absolute;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    z-index:1;
  }
  #ui{
    position:fixed;
    top:1rem; left:50%;
    transform:translateX(-50%);
    color:#fff;
    font-size:1rem;
    text-shadow:1px 1px 2px #000;
    display:flex; gap:1rem; align-items:center;
    z-index:2;
  }
  #nextBtn{
    position:fixed;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    padding:1rem 2rem;
    font-size:1.2rem;
    border:none;
    border-radius:6px;
    background:#28a745;
    color:#fff;
    cursor:pointer;
    display:none;
    z-index:2;
  }
</style>
</head>
<body>
<canvas id="bgCanvas"></canvas>
<canvas id="gameCanvas" width="896" height="512"></canvas>
<div id="ui">
  Corazones <span id="score">0</span>/19 –
  <span>← → correr | ▲ saltar | ▼ bajar | Z atacar | R reiniciar</span>
</div>
<button id="nextBtn">Siguiente ♥</button>

<script>
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');

function resizeBg() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeBg);
resizeBg();


const balls = [];
for(let i=0;i<40;i++){
  balls.push({
    x: Math.random()*bgCanvas.width,
    y: Math.random()*bgCanvas.height,
    r: 8 + Math.random()*4,
    vx: (Math.random()-0.5)*0.5,
    vy: (Math.random()-0.5)*0.5
  });
}


function drawBackground(){
  bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);

  // Fondo base oscuro y uniforme
  bgCtx.fillStyle = 'rgba(20, 30, 60, 0.8)';
  bgCtx.fillRect(0,0,bgCanvas.width,bgCanvas.height);

  // Dibujar balones
  balls.forEach(b=>{
    b.x += b.vx; 
    b.y += b.vy;

    if(b.x<0)b.x=bgCanvas.width;
    if(b.x>bgCanvas.width)b.x=0;
    if(b.y<0)b.y=bgCanvas.height;
    if(b.y>bgCanvas.height)b.y=0;

    // Balón suave
    bgCtx.fillStyle = 'rgba(255,140,0,0.4)';
    bgCtx.beginPath();
    bgCtx.arc(b.x,b.y,b.r,0,Math.PI*2);
    bgCtx.fill();

    // Detalles más transparentes
    bgCtx.strokeStyle = 'rgba(0,0,0,0.2)';
    bgCtx.lineWidth = 1;
    bgCtx.beginPath();
    bgCtx.moveTo(b.x-b.r/2,b.y);
    bgCtx.lineTo(b.x+b.r/2,b.y);
    bgCtx.moveTo(b.x,b.y-b.r/2);
    bgCtx.lineTo(b.x,b.y+b.r/2);
    bgCtx.stroke();
  });
}


const TILE = 32, GRAVITY = 0.5, FRICTION = 0.8, JUMP = 15, FRAME_MS = 120, MAX_COINS = 19;
const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const uiScore = document.getElementById('score'), nextBtn = document.getElementById('nextBtn');

const playerSheet = new Image(); playerSheet.src = 'cowboy_sheet.png';
const enemySheet  = new Image(); enemySheet.src  = 'enemy_sheet.png';
const coinImg     = new Image(); coinImg.src     = 'coin.png';
const spikeImg    = new Image(); spikeImg.src    = 'spike.png';
const hoopImg     = new Image(); hoopImg.src     = 'basket_hoop.png';

const WIDTH_TILES = 200, WORLD_W = WIDTH_TILES * TILE;
const platforms = [{y:15*TILE},{y:10*TILE},{y:6*TILE}];

const coins = [
  {x:200 ,y:platforms[0].y-32},{x:450 ,y:platforms[0].y-32},{x:700 ,y:platforms[0].y-32},
  {x:950 ,y:platforms[0].y-32},{x:1200,y:platforms[0].y-32},
  {x:400 ,y:platforms[1].y-32},{x:650 ,y:platforms[1].y-32},{x:900 ,y:platforms[1].y-32},
  {x:1150,y:platforms[1].y-32},{x:1400,y:platforms[1].y-32},{x:1650,y:platforms[1].y-32},
  {x:700 ,y:platforms[2].y-32},{x:950 ,y:platforms[2].y-32},{x:1200,y:platforms[2].y-32},
  {x:1450,y:platforms[2].y-32},{x:1700,y:platforms[2].y-32},{x:1950,y:platforms[2].y-32},
  {x:2200,y:platforms[2].y-32},
  {x:2400,y:platforms[0].y-32}
];

const spikes = [];
[466+96,1366+96,2266+96,3166+96,4066+96].forEach(x=>spikes.push({x,y:platforms[0].y-TILE}));
[616+96,916+96 ,1216+96,1516+96]         .forEach(x=>spikes.push({x,y:platforms[1].y-TILE}));
[816+96,1116+96,1416+96,1716+96]         .forEach(x=>spikes.push({x,y:platforms[2].y-TILE}));

const goalX = WORLD_W - 4 * TILE;

const SPR_COLS = 3, SPR_ROWS = 2;
let SPR_W=0, SPR_H=0;
const ANIM = { idle:[[0,0]], run:[[1,0],[2,0]], jump:[[2,1]] };

const ENEMY_SCALE = 0.15; let EW_SRC=0, EH_SRC=0;
class FinalEnemy {
  constructor(){ this.reset(); }
  reset(){
    this.w=EW_SRC*ENEMY_SCALE;
    this.h=EH_SRC*ENEMY_SCALE;
    this.x=-9999; this.y=platforms[0].y-this.h;
    this.vx=-2; this.active=false; this.defeated=false;
    this.hits=0; this.fade=1; this.spawned=false;
  }
  activateOnce(){ if(!this.spawned){ this.x=goalX-160; this.active=true; this.spawned=true; } }
  near(pl){ return Math.abs(this.x-pl.x)<90 && Math.abs(this.y-pl.y)<70; }
  hit(){ if(++this.hits>=2){ this.defeated=true; this.fade=1; } }
  update(){
    if(!this.active) return;
    if(!this.defeated){ this.x+=this.vx; if(this.x<-this.w) this.active=false; }
    else{ this.fade-=0.05; if(this.fade<=0) this.active=false; }
  }
  draw(cam){
    if(!this.active) return;
    ctx.save(); ctx.globalAlpha=this.fade;
    ctx.drawImage(enemySheet,0,0,EW_SRC,EH_SRC,this.x-cam,this.y,this.w,this.h);
    ctx.restore();
  }
}
const finalEnemy = new FinalEnemy();

class Player {
  constructor(){ this.dropTimer=0; this.reset(); }
  reset(){
    this.x=64; this.y=platforms[0].y-96;
    this.vx=this.vy=0; this.h=96;
    this.w=SPR_H ? Math.round(SPR_W*this.h/SPR_H) : 48;
    this.onGround=false; this.facing=1; this.state='idle';
    this.frame=0; this.lastTime=performance.now();
    this.coinCount=0; uiScore.textContent=0;
    nextBtn.style.display='none'; coins.forEach(c=>c.collected=false);
    finalEnemy.reset(); this.dropTimer=0;
  }
  update(k){
    if(k.left){ this.vx=-4; this.facing=-1; } else if(k.right){ this.vx=4; this.facing=1; } else this.vx *= FRICTION;
    if(k.down && this.onGround && this.dropTimer<=0){ this.onGround=false; this.y+=2; this.vy=2; this.dropTimer=15; }
    if(this.dropTimer>0) this.dropTimer--;
    if(k.jump && this.onGround){ this.vy=-JUMP; this.onGround=false; this.dropTimer=0; }
    this.vy += GRAVITY; this.x += this.vx; this.y += this.vy;

    this.onGround=false;
    for(const p of platforms){
      if(this.vy>=0 && this.y+this.h>=p.y-10 && this.y+this.h<=p.y+10 && this.x+this.w>0 && this.x<WORLD_W){
        if(this.dropTimer<=0){ this.y=p.y-this.h; this.vy=0; this.onGround=true; }
      }
    }
    if(this.y + this.h > platforms[0].y){ this.y = platforms[0].y - this.h; this.vy = 0; this.onGround = true; this.dropTimer=0; }

    coins.forEach(c => { 
      if(!c.collected && this.overlapRect(c,16,16)){
        c.collected = true; 
        uiScore.textContent = ++this.coinCount; 
      }
    });
    if(spikes.some(s => this.overlapRect(s,32,32))){ this.reset(); return; }

    if(this.coinCount === MAX_COINS) finalEnemy.activateOnce();
    if(k.z && finalEnemy.active && !finalEnemy.defeated && finalEnemy.near(this)) finalEnemy.hit();
    if(finalEnemy.active && !finalEnemy.defeated && this.overlapRect(finalEnemy,finalEnemy.w,finalEnemy.h)) this.reset();

    if(this.coinCount === MAX_COINS && this.overlap(goalX,platforms[0].y-64,32,64)) nextBtn.style.display='block';

    const newState = !this.onGround ? 'jump' : (Math.abs(this.vx)>0.5 ? 'run' : 'idle');
    if(newState !== this.state){ this.state = newState; this.frame = 0; this.lastTime = performance.now(); }
    else if(performance.now() - this.lastTime > FRAME_MS){ this.lastTime = performance.now(); this.frame = (this.frame+1) % ANIM[this.state].length; }
  }
  draw(cam){
    const [c,r]=ANIM[this.state][this.frame];
    ctx.save();
    if(this.facing === -1){ ctx.translate(this.x-cam+this.w,this.y); ctx.scale(-1,1); }
    else ctx.translate(this.x-cam,this.y);
    ctx.drawImage(playerSheet,c*SPR_W,r*SPR_H,SPR_W,SPR_H,0,0,this.w,this.h);
    ctx.restore();
  }
  overlapRect(o,w,h){ return this.overlap(o.x,o.y,w,h); }
  overlap(ox,oy,ow,oh){ return this.x<ox+ow && this.x+this.w>ox && this.y<oy+oh && this.y+this.h>oy; }
}

const player = new Player();
const keys = {left:0,right:0,up:0,down:0,jump:0,z:0};
onkeydown = e => {
  if(e.code==='ArrowLeft')keys.left=1;
  if(e.code==='ArrowRight')keys.right=1;
  if(e.code==='ArrowUp')keys.jump=1;
  if(e.code==='ArrowDown')keys.down=1;
  if(e.code==='KeyZ')keys.z=1;
  if(e.code==='KeyR')player.reset();
};
onkeyup = e => {
  if(e.code==='ArrowLeft')keys.left=0;
  if(e.code==='ArrowRight')keys.right=0;
  if(e.code==='ArrowUp')keys.jump=0;
  if(e.code==='ArrowDown')keys.down=0;
  if(e.code==='KeyZ')keys.z=0;
};

function loop(){
  drawBackground(); // dibuja fondo con balones suavizados
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const cam=Math.max(0,Math.min(player.x-canvas.width/2,WORLD_W-canvas.width));
  drawWorld(cam); player.update(keys); player.draw(cam);
  finalEnemy.update(); finalEnemy.draw(cam);
  requestAnimationFrame(loop);
}

function drawWorld(cam){
  ctx.fillStyle='#8b4513'; platforms.forEach(p=>ctx.fillRect(0,p.y,canvas.width,TILE));
  coins.forEach(c => { if(!c.collected && c.x>cam-32 && c.x<cam+canvas.width+32) ctx.drawImage(coinImg,c.x-cam,c.y,16,16); });
  spikes.forEach(s => { if(s.x>cam-32 && s.x<cam+canvas.width+32) ctx.drawImage(spikeImg,s.x-cam,s.y,32,32); });
  ctx.drawImage(hoopImg,goalX-cam,platforms[0].y-64,32,64);
}

let loaded=0;
function tryStart(){
  if(++loaded===2){
    SPR_W = playerSheet.naturalWidth / SPR_COLS;
    SPR_H = playerSheet.naturalHeight / SPR_ROWS;
    EW_SRC = enemySheet.naturalWidth / 2;
    EH_SRC = enemySheet.naturalHeight;
    player.w = Math.round(SPR_W * player.h / SPR_H);
    loop();
  }
}
playerSheet.onload = tryStart;
enemySheet.onload = tryStart;

nextBtn.onclick = () => {
  window.location.href = 'elden.html';
};
</script>
</body>
</html>
